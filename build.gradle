plugins {
    id 'java'
    id 'application'                           //adds the run task. also adds application{main-class} line below
//    id 'java-library'                        //adds api command!
    id 'me.champeau.jmh' version '0.6.7'       //jmh benchmarking plugin
    id 'com.palantir.docker' version '0.34.0'       //docker plugin - creating image
    id 'com.palantir.docker-run' version '0.34.0'   //docker plugin - running the image
    id 'org.graalvm.buildtools.native' version '0.9.20'  //graalvm w/ native-image
}

group 'org.core'
version '2.0-SNAPSHOT'
java.sourceCompatibility JavaVersion.VERSION_19


/* for java -jar ..`
 * add below to use 'java -jar ..' command!
 * else use 'gradle run' or 'java -cp ...jar className'
 *
 * for multi-modules, inject into related build.gradle
 */
jar {
    manifest {
        attributes('Implementation-Title': 'Gradle Backbone',
                'Implementation-Version': archiveVersion,
//                   'Class-Path': configurations.compile.collect { it.getName() }.join(' '),
                'Main-Class': 'org.core.Main')

    }
}

/* for gradle run task
 *
 * Define the (full path) main class for the application.
 */
application {

    mainClass = 'org.core.Main'
}

repositories {
    mavenCentral()
    gradlePluginPortal()    //not yet defined in gradle plugin repository
}

dependencies {

    /* for multi-modules projects, to be able to include other projects
     *   - here, implementation dependency, for build/run tasks
     *   - in java commands, use -cp to add core project jar, too!! (java -cp ..jar:..core.jar org.MainBlaBla)
     */
//    implementation project(':core')

    testImplementation 'org.junit.jupiter:junit-jupiter:5.9.2'

    //for src.jmh folder.. package names must be the same with main module!!
    jmh 'org.openjdk.jmh:jmh-core:1.35'
    jmh 'org.openjdk.jmh:jmh-generator-annprocess:1.35'

    //that solves the missing /META-INF/BenchmarkList error
    jmhAnnotationProcessor 'org.openjdk.jmh:jmh-generator-annprocess:1.35'
}

test {
    //for junit5
    useJUnitPlatform()
}

//palantir docker plugin - creates image
//workingDir is under build/docker, so we need to copy some files to
//work with existing Dockerfile !
//./gradlew docker              or docker build -t gradle-backbone:0.0.2-SNAPSHOT .
//./gradlew dockerTag
//./gradlew dockerPushDockerHub or  docker push tansudasli/gradle-backbone:1.0-SNAPSHOT
docker {
    name "${project.name}:${project.version}"

    dockerfile file('Dockerfile')
    copySpec.from("./build/libs/").into("./build/libs/")

    tag 'DockerHub', "tansudasli/${project.name}:${project.version}"

}

//palantir docker run plugin - runs image
//./gradlew dockerRun
dockerRun {
    name "${project.name}"
    image "${project.name}:${project.version}"
//    ports '8080:8080'
}

//graalvm native image config
graalvmNative {
    binaries.all {
        resources.autodetect()
    }

    //if you need other main files, add below!
    //below adds new gradle tasks !
    binaries {
        Main {
            // Main options
            imageName = "${project.name}.Main" // The name of the native image, defaults to the project name
            mainClass = 'org.core.Main'
        }

        MainStream {
            // Main options
            imageName = "${project.name}.MainStream" // The name of the native image, defaults to the project name
            mainClass = 'org.core.MainStream'
            classpath("build/libs/${project.name}-${version}.jar")

        }

        MainParallelStream {
            // Main options
            imageName = "${project.name}.MainParallelStream" // The name of the native image, defaults to the project name
            mainClass = 'org.core.MainParallelStream'
            classpath("build/libs/${project.name}-${version}.jar")

        }
    }
//    toolchainDetection = false
}


/* for custom task definition
 * register first, then define
 */
tasks.register('hi') {
    description 'to see some parameter values'

    println "hi"
    println ant
    println buildDir
}